{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keywordCode = void 0;\nconst context_1 = require(\"../context\");\nconst errors_1 = require(\"../errors\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new context_1.default(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def);\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def);\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def);\n  }\n}\nexports.keywordCode = keywordCode;\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsync(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid(codegen_1._`await `), e => gen.assign(valid, false).if(codegen_1._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n  function validateSync() {\n    const validateErrs = codegen_1._`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid(_await = def.async ? codegen_1._`await ` : codegen_1.nil) {\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, codegen_1._`${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, codegen_1._`${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if(codegen_1._`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);\n    errors_1.extendErrors(cxt);\n  }, () => cxt.error());\n}\nfunction checkAsync({\n  schemaEnv\n}, def) {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: codegen_1.stringify(result)\n  });\n}","map":{"version":3,"names":["context_1","require","errors_1","code_1","codegen_1","names_1","keywordCode","it","keyword","def","ruleType","cxt","default","code","$data","validate","funcKeywordCode","macroKeywordCode","compile","exports","gen","schema","parentSchema","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","nil","errSchemaPath","topSchemaRef","compositeRule","pass","error","checkAsync","validateRef","let","block$data","validateKeyword","ok","_a","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","_","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","this","passSchema","callValidateCode","not","data","parentData","parentDataProperty","errs","vErrors","extendErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","stringify"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\validate\\keyword.ts"],"sourcesContent":["import type {\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType} from \"../rules\"\nimport KeywordCxt from \"../context\"\nimport {extendErrors} from \"../errors\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {CodeGen, _, nil, not, stringify, Code, Name} from \"../codegen\"\nimport N from \"../names\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nfunction macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nfunction funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsync(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsync({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}