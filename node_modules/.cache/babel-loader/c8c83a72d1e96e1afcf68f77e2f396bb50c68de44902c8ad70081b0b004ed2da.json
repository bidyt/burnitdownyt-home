{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.schemaCxtHasRules = exports.subschemaCode = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst iterate_1 = require(\"./iterate\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({\n  gen,\n  validateName,\n  schema,\n  schemaEnv,\n  opts\n}, body) {\n  if (opts.code.es5) {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code(codegen_1._`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\nfunction destructureValCxt(opts) {\n  return codegen_1._`{${names_1.default.dataPath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.dataPath, codegen_1._`${names_1.default.valCxt}.${names_1.default.dataPath}`);\n    gen.var(names_1.default.parentData, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, codegen_1._`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.dataPath, codegen_1._`\"\"`);\n    gen.var(names_1.default.parentData, codegen_1._`undefined`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`{}`);\n  });\n}\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", codegen_1._`${validateName}.evaluated`);\n  gen.if(codegen_1._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._`${it.evaluated}.props`, codegen_1._`undefined`));\n  gen.if(codegen_1._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._`${it.evaluated}.items`, codegen_1._`undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n  return typeof schema == \"object\" && schema.$id && (opts.code.source || opts.code.process) ? codegen_1._`/*# sourceURL=${schema.$id} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  boolSchema_1.boolOrEmptySchema(it, valid);\n}\nexports.subschemaCode = subschemaCode;\nfunction schemaCxtHasRules({\n  schema,\n  self\n}) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (self.RULES.all[key]) return true;\n  return false;\n}\nexports.schemaCxtHasRules = schemaCxtHasRules;\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsync(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, codegen_1._`${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n  util_1.checkUnknownRules(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return iterate_1.schemaKeywords(it, [], false, errsCount);\n  const types = dataType_1.getSchemaTypes(it.schema);\n  const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n  iterate_1.schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n  if (schema.default !== undefined && opts.useDefaults && opts.strict) {\n    checkStrictMode(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  if (it.schema.$id) it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);\n}\nfunction checkAsync(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({\n  gen,\n  schemaEnv,\n  schema,\n  errSchemaPath,\n  opts\n}) {\n  const msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code(codegen_1._`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = codegen_1.str`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code(codegen_1._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(codegen_1._`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign(codegen_1._`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return(codegen_1._`${names_1.default.errors} === 0`);\n  }\n}\nfunction assignEvaluated({\n  gen,\n  evaluated,\n  props,\n  items\n}) {\n  if (props instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.items`, items);\n}\nfunction checkStrictMode(it, msg, mode = it.opts.strict) {\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"names":["boolSchema_1","require","dataType_1","iterate_1","codegen_1","names_1","resolve_1","util_1","validateFunctionCode","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","topBoolOrEmptySchema","exports","gen","validateName","schema","schemaEnv","opts","body","code","es5","func","_","default","data","valCxt","$async","funcSourceUrl","destructureValCxtES5","destructureValCxt","dataPath","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","nil","if","var","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","assign","$id","source","process","subschemaCode","valid","subSchemaObjCode","boolOrEmptySchema","self","key","RULES","all","updateContext","checkAsync","errsCount","checkUnknownRules","checkRefsAndKeywords","jtd","schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","errSchemaPath","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","undefined","useDefaults","strict","checkStrictMode","baseId","resolveUrl","Error","msg","schemaPath","str","rootName","scopeValue","ref","root","ValidationError","return","throw","assignEvaluated","props","items","Name","mode"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\validate\\index.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {schemaKeywords} from \"./iterate\"\nimport {_, nil, str, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {schemaHasRulesButRef, checkUnknownRules} from \"../util\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.dataPath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${N.data}${\n    opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil\n  }}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.dataPath, _`${N.valCxt}.${N.dataPath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.dataPath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  return typeof schema == \"object\" && schema.$id && (opts.code.source || opts.code.process)\n    ? _`/*# sourceURL=${schema.$id} */`\n    : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nexport function subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nexport function schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsync(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strict) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  if (it.schema.$id) it.baseId = resolveUrl(it.baseId, it.schema.$id)\n}\n\nfunction checkAsync(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nexport function checkStrictMode(it: SchemaCxt, msg: string, mode = it.opts.strict): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n"],"mappings":";;;;;;AAGA,MAAAA,YAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,SAAA,GAAAF,OAAA;AACA,MAAAG,SAAA,GAAAH,OAAA;AACA,MAAAI,OAAA,GAAAJ,OAAA;AACA,MAAAK,SAAA,GAAAL,OAAA;AACA,MAAAM,MAAA,GAAAN,OAAA;AAEA;AACA,SAAgBO,oBAAoBA,CAACC,EAAa;EAChD,IAAIC,WAAW,CAACD,EAAE,CAAC,EAAE;IACnBE,aAAa,CAACF,EAAE,CAAC;IACjB,IAAIG,iBAAiB,CAACH,EAAE,CAAC,EAAE;MACzBI,gBAAgB,CAACJ,EAAE,CAAC;MACpB;;;EAGJK,gBAAgB,CAACL,EAAE,EAAE,MAAMT,YAAA,CAAAe,oBAAoB,CAACN,EAAE,CAAC,CAAC;AACtD;AATAO,OAAA,CAAAR,oBAAA,GAAAA,oBAAA;AAWA,SAASM,gBAAgBA,CACvB;EAACG,GAAG;EAAEC,YAAY;EAAEC,MAAM;EAAEC,SAAS;EAAEC;AAAI,CAAY,EACvDC,IAAW;EAEX,IAAID,IAAI,CAACE,IAAI,CAACC,GAAG,EAAE;IACjBP,GAAG,CAACQ,IAAI,CAACP,YAAY,EAAEd,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACC,IAAI,KAAKvB,OAAA,CAAAsB,OAAC,CAACE,MAAM,EAAE,EAAET,SAAS,CAACU,MAAM,EAAE,MAAK;MACvEb,GAAG,CAACM,IAAI,CAACnB,SAAA,CAAAsB,CAAC,iBAAiBK,aAAa,CAACZ,MAAM,EAAEE,IAAI,CAAC,EAAE,CAAC;MACzDW,oBAAoB,CAACf,GAAG,EAAEI,IAAI,CAAC;MAC/BJ,GAAG,CAACM,IAAI,CAACD,IAAI,CAAC;IAChB,CAAC,CAAC;GACH,MAAM;IACLL,GAAG,CAACQ,IAAI,CAACP,YAAY,EAAEd,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACC,IAAI,KAAKK,iBAAiB,CAACZ,IAAI,CAAC,EAAE,EAAED,SAAS,CAACU,MAAM,EAAE,MACjFb,GAAG,CAACM,IAAI,CAACQ,aAAa,CAACZ,MAAM,EAAEE,IAAI,CAAC,CAAC,CAACE,IAAI,CAACD,IAAI,CAAC,CACjD;;AAEL;AAEA,SAASW,iBAAiBA,CAACZ,IAAqB;EAC9C,OAAOjB,SAAA,CAAAsB,CAAC,IAAIrB,OAAA,CAAAsB,OAAC,CAACO,QAAQ,QAAQ7B,OAAA,CAAAsB,OAAC,CAACQ,UAAU,KAAK9B,OAAA,CAAAsB,OAAC,CAACS,kBAAkB,KAAK/B,OAAA,CAAAsB,OAAC,CAACU,QAAQ,IAAIhC,OAAA,CAAAsB,OAAC,CAACC,IAAI,GAC1FP,IAAI,CAACiB,UAAU,GAAGlC,SAAA,CAAAsB,CAAC,KAAKrB,OAAA,CAAAsB,OAAC,CAACY,cAAc,KAAK,GAAGnC,SAAA,CAAAoC,GAClD,MAAM;AACR;AAEA,SAASR,oBAAoBA,CAACf,GAAY,EAAEI,IAAqB;EAC/DJ,GAAG,CAACwB,EAAE,CACJpC,OAAA,CAAAsB,OAAC,CAACE,MAAM,EACR,MAAK;IACHZ,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACO,QAAQ,EAAE9B,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACE,MAAM,IAAIxB,OAAA,CAAAsB,OAAC,CAACO,QAAQ,EAAE,CAAC;IACjDjB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACQ,UAAU,EAAE/B,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACE,MAAM,IAAIxB,OAAA,CAAAsB,OAAC,CAACQ,UAAU,EAAE,CAAC;IACrDlB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACS,kBAAkB,EAAEhC,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACE,MAAM,IAAIxB,OAAA,CAAAsB,OAAC,CAACS,kBAAkB,EAAE,CAAC;IACrEnB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACU,QAAQ,EAAEjC,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACE,MAAM,IAAIxB,OAAA,CAAAsB,OAAC,CAACU,QAAQ,EAAE,CAAC;IACjD,IAAIhB,IAAI,CAACiB,UAAU,EAAErB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACY,cAAc,EAAEnC,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACE,MAAM,IAAIxB,OAAA,CAAAsB,OAAC,CAACY,cAAc,EAAE,CAAC;EACpF,CAAC,EACD,MAAK;IACHtB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACO,QAAQ,EAAE9B,SAAA,CAAAsB,CAAC,IAAI,CAAC;IAC1BT,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACQ,UAAU,EAAE/B,SAAA,CAAAsB,CAAC,WAAW,CAAC;IACnCT,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACS,kBAAkB,EAAEhC,SAAA,CAAAsB,CAAC,WAAW,CAAC;IAC3CT,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACU,QAAQ,EAAEhC,OAAA,CAAAsB,OAAC,CAACC,IAAI,CAAC;IAC3B,IAAIP,IAAI,CAACiB,UAAU,EAAErB,GAAG,CAACyB,GAAG,CAACrC,OAAA,CAAAsB,OAAC,CAACY,cAAc,EAAEnC,SAAA,CAAAsB,CAAC,IAAI,CAAC;EACvD,CAAC,CACF;AACH;AAEA,SAASb,gBAAgBA,CAACJ,EAAgB;EACxC,MAAM;IAACU,MAAM;IAAEE,IAAI;IAAEJ;EAAG,CAAC,GAAGR,EAAE;EAC9BK,gBAAgB,CAACL,EAAE,EAAE,MAAK;IACxB,IAAIY,IAAI,CAACsB,QAAQ,IAAIxB,MAAM,CAACwB,QAAQ,EAAEC,cAAc,CAACnC,EAAE,CAAC;IACxDoC,cAAc,CAACpC,EAAE,CAAC;IAClBQ,GAAG,CAAC6B,GAAG,CAACzC,OAAA,CAAAsB,OAAC,CAACoB,OAAO,EAAE,IAAI,CAAC;IACxB9B,GAAG,CAAC6B,GAAG,CAACzC,OAAA,CAAAsB,OAAC,CAACqB,MAAM,EAAE,CAAC,CAAC;IACpB,IAAI3B,IAAI,CAAC4B,WAAW,EAAEC,cAAc,CAACzC,EAAE,CAAC;IACxC0C,eAAe,CAAC1C,EAAE,CAAC;IACnB2C,aAAa,CAAC3C,EAAE,CAAC;EACnB,CAAC,CAAC;EACF;AACF;AAEA,SAASyC,cAAcA,CAACzC,EAAgB;EACtC;EACA,MAAM;IAACQ,GAAG;IAAEC;EAAY,CAAC,GAAGT,EAAE;EAC9BA,EAAE,CAAC4C,SAAS,GAAGpC,GAAG,CAACqC,KAAK,CAAC,WAAW,EAAElD,SAAA,CAAAsB,CAAC,GAAGR,YAAY,YAAY,CAAC;EACnED,GAAG,CAACwB,EAAE,CAACrC,SAAA,CAAAsB,CAAC,GAAGjB,EAAE,CAAC4C,SAAS,eAAe,EAAE,MAAMpC,GAAG,CAACsC,MAAM,CAACnD,SAAA,CAAAsB,CAAC,GAAGjB,EAAE,CAAC4C,SAAS,QAAQ,EAAEjD,SAAA,CAAAsB,CAAC,WAAW,CAAC,CAAC;EACjGT,GAAG,CAACwB,EAAE,CAACrC,SAAA,CAAAsB,CAAC,GAAGjB,EAAE,CAAC4C,SAAS,eAAe,EAAE,MAAMpC,GAAG,CAACsC,MAAM,CAACnD,SAAA,CAAAsB,CAAC,GAAGjB,EAAE,CAAC4C,SAAS,QAAQ,EAAEjD,SAAA,CAAAsB,CAAC,WAAW,CAAC,CAAC;AACnG;AAEA,SAASK,aAAaA,CAACZ,MAAiB,EAAEE,IAAqB;EAC7D,OAAO,OAAOF,MAAM,IAAI,QAAQ,IAAIA,MAAM,CAACqC,GAAG,KAAKnC,IAAI,CAACE,IAAI,CAACkC,MAAM,IAAIpC,IAAI,CAACE,IAAI,CAACmC,OAAO,CAAC,GACrFtD,SAAA,CAAAsB,CAAC,iBAAiBP,MAAM,CAACqC,GAAG,KAAK,GACjCpD,SAAA,CAAAoC,GAAG;AACT;AAEA;AACA,SAAgBmB,aAAaA,CAAClD,EAAa,EAAEmD,KAAW;EACtD,IAAIlD,WAAW,CAACD,EAAE,CAAC,EAAE;IACnBE,aAAa,CAACF,EAAE,CAAC;IACjB,IAAIG,iBAAiB,CAACH,EAAE,CAAC,EAAE;MACzBoD,gBAAgB,CAACpD,EAAE,EAAEmD,KAAK,CAAC;MAC3B;;;EAGJ5D,YAAA,CAAA8D,iBAAiB,CAACrD,EAAE,EAAEmD,KAAK,CAAC;AAC9B;AATA5C,OAAA,CAAA2C,aAAA,GAAAA,aAAA;AAWA,SAAgB/C,iBAAiBA,CAAC;EAACO,MAAM;EAAE4C;AAAI,CAAY;EACzD,IAAI,OAAO5C,MAAM,IAAI,SAAS,EAAE,OAAO,CAACA,MAAM;EAC9C,KAAK,MAAM6C,GAAG,IAAI7C,MAAM,EAAE,IAAI4C,IAAI,CAACE,KAAK,CAACC,GAAG,CAACF,GAAG,CAAC,EAAE,OAAO,IAAI;EAC9D,OAAO,KAAK;AACd;AAJAhD,OAAA,CAAAJ,iBAAA,GAAAA,iBAAA;AAMA,SAASF,WAAWA,CAACD,EAAa;EAChC,OAAO,OAAOA,EAAE,CAACU,MAAM,IAAI,SAAS;AACtC;AAEA,SAAS0C,gBAAgBA,CAACpD,EAAgB,EAAEmD,KAAW;EACrD,MAAM;IAACzC,MAAM;IAAEF,GAAG;IAAEI;EAAI,CAAC,GAAGZ,EAAE;EAC9B,IAAIY,IAAI,CAACsB,QAAQ,IAAIxB,MAAM,CAACwB,QAAQ,EAAEC,cAAc,CAACnC,EAAE,CAAC;EACxD0D,aAAa,CAAC1D,EAAE,CAAC;EACjB2D,UAAU,CAAC3D,EAAE,CAAC;EACd,MAAM4D,SAAS,GAAGpD,GAAG,CAACqC,KAAK,CAAC,OAAO,EAAEjD,OAAA,CAAAsB,OAAC,CAACqB,MAAM,CAAC;EAC9CG,eAAe,CAAC1C,EAAE,EAAE4D,SAAS,CAAC;EAC9B;EACApD,GAAG,CAACyB,GAAG,CAACkB,KAAK,EAAExD,SAAA,CAAAsB,CAAC,GAAG2C,SAAS,QAAQhE,OAAA,CAAAsB,OAAC,CAACqB,MAAM,EAAE,CAAC;AACjD;AAEA,SAASrC,aAAaA,CAACF,EAAgB;EACrCF,MAAA,CAAA+D,iBAAiB,CAAC7D,EAAE,CAAC;EACrB8D,oBAAoB,CAAC9D,EAAE,CAAC;AAC1B;AAEA,SAAS0C,eAAeA,CAAC1C,EAAgB,EAAE4D,SAAgB;EACzD,IAAI5D,EAAE,CAACY,IAAI,CAACmD,GAAG,EAAE,OAAOrE,SAAA,CAAAsE,cAAc,CAAChE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE4D,SAAS,CAAC;EAChE,MAAMK,KAAK,GAAGxE,UAAA,CAAAyE,cAAc,CAAClE,EAAE,CAACU,MAAM,CAAC;EACvC,MAAMyD,YAAY,GAAG1E,UAAA,CAAA2E,sBAAsB,CAACpE,EAAE,EAAEiE,KAAK,CAAC;EACtDvE,SAAA,CAAAsE,cAAc,CAAChE,EAAE,EAAEiE,KAAK,EAAE,CAACE,YAAY,EAAEP,SAAS,CAAC;AACrD;AAEA,SAASE,oBAAoBA,CAAC9D,EAAgB;EAC5C,MAAM;IAACU,MAAM;IAAE2D,aAAa;IAAEzD,IAAI;IAAE0C;EAAI,CAAC,GAAGtD,EAAE;EAC9C,IAAIU,MAAM,CAAC4D,IAAI,IAAI1D,IAAI,CAAC2D,qBAAqB,IAAIzE,MAAA,CAAA0E,oBAAoB,CAAC9D,MAAM,EAAE4C,IAAI,CAACE,KAAK,CAAC,EAAE;IACzFF,IAAI,CAACmB,MAAM,CAACC,IAAI,CAAC,6CAA6CL,aAAa,GAAG,CAAC;;AAEnF;AAEA,SAASjC,cAAcA,CAACpC,EAAgB;EACtC,MAAM;IAACU,MAAM;IAAEE;EAAI,CAAC,GAAGZ,EAAE;EACzB,IAAIU,MAAM,CAACQ,OAAO,KAAKyD,SAAS,IAAI/D,IAAI,CAACgE,WAAW,IAAIhE,IAAI,CAACiE,MAAM,EAAE;IACnEC,eAAe,CAAC9E,EAAE,EAAE,uCAAuC,CAAC;;AAEhE;AAEA,SAAS0D,aAAaA,CAAC1D,EAAgB;EACrC,IAAIA,EAAE,CAACU,MAAM,CAACqC,GAAG,EAAE/C,EAAE,CAAC+E,MAAM,GAAGlF,SAAA,CAAAmF,UAAU,CAAChF,EAAE,CAAC+E,MAAM,EAAE/E,EAAE,CAACU,MAAM,CAACqC,GAAG,CAAC;AACrE;AAEA,SAASY,UAAUA,CAAC3D,EAAgB;EAClC,IAAIA,EAAE,CAACU,MAAM,CAACW,MAAM,IAAI,CAACrB,EAAE,CAACW,SAAS,CAACU,MAAM,EAAE,MAAM,IAAI4D,KAAK,CAAC,6BAA6B,CAAC;AAC9F;AAEA,SAAS9C,cAAcA,CAAC;EAAC3B,GAAG;EAAEG,SAAS;EAAED,MAAM;EAAE2D,aAAa;EAAEzD;AAAI,CAAe;EACjF,MAAMsE,GAAG,GAAGxE,MAAM,CAACwB,QAAQ;EAC3B,IAAItB,IAAI,CAACsB,QAAQ,KAAK,IAAI,EAAE;IAC1B1B,GAAG,CAACM,IAAI,CAACnB,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACoC,IAAI,eAAe4B,GAAG,GAAG,CAAC;GAC1C,MAAM,IAAI,OAAOtE,IAAI,CAACsB,QAAQ,IAAI,UAAU,EAAE;IAC7C,MAAMiD,UAAU,GAAGxF,SAAA,CAAAyF,GAAG,GAAGf,aAAa,WAAW;IACjD,MAAMgB,QAAQ,GAAG7E,GAAG,CAAC8E,UAAU,CAAC,MAAM,EAAE;MAACC,GAAG,EAAE5E,SAAS,CAAC6E;IAAI,CAAC,CAAC;IAC9DhF,GAAG,CAACM,IAAI,CAACnB,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACoC,IAAI,kBAAkB4B,GAAG,KAAKC,UAAU,KAAKE,QAAQ,UAAU,CAAC;;AAEnF;AAEA,SAAS1C,aAAaA,CAAC3C,EAAa;EAClC,MAAM;IAACQ,GAAG;IAAEG,SAAS;IAAEF,YAAY;IAAEgF,eAAe;IAAE7E;EAAI,CAAC,GAAGZ,EAAE;EAChE,IAAIW,SAAS,CAACU,MAAM,EAAE;IACpB;IACAb,GAAG,CAACwB,EAAE,CACJrC,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACqB,MAAM,QAAQ,EACpB,MAAM/B,GAAG,CAACkF,MAAM,CAAC9F,OAAA,CAAAsB,OAAC,CAACC,IAAI,CAAC,EACxB,MAAMX,GAAG,CAACmF,KAAK,CAAChG,SAAA,CAAAsB,CAAC,OAAOwE,eAAuB,IAAI7F,OAAA,CAAAsB,OAAC,CAACoB,OAAO,GAAG,CAAC,CACjE;GACF,MAAM;IACL9B,GAAG,CAACsC,MAAM,CAACnD,SAAA,CAAAsB,CAAC,GAAGR,YAAY,SAAS,EAAEb,OAAA,CAAAsB,OAAC,CAACoB,OAAO,CAAC;IAChD,IAAI1B,IAAI,CAAC4B,WAAW,EAAEoD,eAAe,CAAC5F,EAAE,CAAC;IACzCQ,GAAG,CAACkF,MAAM,CAAC/F,SAAA,CAAAsB,CAAC,GAAGrB,OAAA,CAAAsB,OAAC,CAACqB,MAAM,QAAQ,CAAC;;AAEpC;AAEA,SAASqD,eAAeA,CAAC;EAACpF,GAAG;EAAEoC,SAAS;EAAEiD,KAAK;EAAEC;AAAK,CAAY;EAChE,IAAID,KAAK,YAAYlG,SAAA,CAAAoG,IAAI,EAAEvF,GAAG,CAACsC,MAAM,CAACnD,SAAA,CAAAsB,CAAC,GAAG2B,SAAS,QAAQ,EAAEiD,KAAK,CAAC;EACnE,IAAIC,KAAK,YAAYnG,SAAA,CAAAoG,IAAI,EAAEvF,GAAG,CAACsC,MAAM,CAACnD,SAAA,CAAAsB,CAAC,GAAG2B,SAAS,QAAQ,EAAEkD,KAAK,CAAC;AACrE;AAEA,SAAgBhB,eAAeA,CAAC9E,EAAa,EAAEkF,GAAW,EAAEc,IAAI,GAAGhG,EAAE,CAACY,IAAI,CAACiE,MAAM;EAC/E,IAAI,CAACmB,IAAI,EAAE;EACXd,GAAG,GAAG,gBAAgBA,GAAG,EAAE;EAC3B,IAAIc,IAAI,KAAK,IAAI,EAAE,MAAM,IAAIf,KAAK,CAACC,GAAG,CAAC;EACvClF,EAAE,CAACsD,IAAI,CAACmB,MAAM,CAACC,IAAI,CAACQ,GAAG,CAAC;AAC1B;AALA3E,OAAA,CAAAuE,eAAA,GAAAA,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}