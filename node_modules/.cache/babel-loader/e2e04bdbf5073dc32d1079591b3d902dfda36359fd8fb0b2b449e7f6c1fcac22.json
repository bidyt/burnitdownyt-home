{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.schemaKeywords = void 0;\nconst applicability_1 = require(\"./applicability\");\nconst dataType_1 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst util_1 = require(\"../util\");\nconst _1 = require(\".\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keyword_1.keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!applicability_1.shouldUseGroup(schema, group)) return;\n    if (group.type) {\n      gen.if(dataType_1.checkDataType(group.type, data, opts.strict));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        dataType_1.reportTypeError(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(codegen_1._`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\nexports.schemaKeywords = schemaKeywords;\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) defaults_1.assignDefaults(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (applicability_1.shouldUseRule(schema, rule)) {\n        keyword_1.keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(t => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n    if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  _1.checkStrictMode(it, msg, it.opts.strictTypes);\n}","map":{"version":3,"names":["applicability_1","require","dataType_1","defaults_1","keyword_1","util_1","_1","codegen_1","names_1","schemaKeywords","it","types","typeErrors","errsCount","gen","schema","data","allErrors","opts","self","RULES","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","block","keywordCode","all","definition","jtd","checkStrictTypes","group","rules","groupKeywords","post","shouldUseGroup","type","if","checkDataType","strict","iterateKeywords","length","else","reportTypeError","endIf","_","default","errors","exports","useDefaults","assignDefaults","rule","shouldUseRule","keyword","schemaEnv","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","filter","ts","includes","some","hasApplicableType","schTs","kwdT","msg","schemaPath","baseId","errSchemaPath","checkStrictMode"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\validate\\iterate.ts"],"sourcesContent":["import type {SchemaObjCxt} from \"..\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, reportTypeError} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {keywordCode} from \"./keyword\"\nimport {schemaHasRulesButRef} from \"../util\"\nimport {checkStrictMode} from \".\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nexport function schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strict))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}