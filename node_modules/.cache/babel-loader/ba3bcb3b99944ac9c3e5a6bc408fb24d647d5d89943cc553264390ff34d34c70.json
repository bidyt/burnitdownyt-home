{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\nconst URI = require(\"uri-js\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\nfunction inlineRef(schema, limit = true) {\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n  return false;\n}\nfunction countKeys(schema) {\n  let count = 0;\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n    if (typeof schema[key] == \"object\") {\n      util_1.eachItem(schema[key], sch => count += countKeys(sch));\n    }\n    if (count === Infinity) return Infinity;\n  }\n  return count;\n}\nfunction getFullPath(id = \"\", normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  const p = URI.parse(id);\n  return _getFullPath(p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(p) {\n  return URI.serialize(p).split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema) {\n  if (typeof schema == \"boolean\") return {};\n  const schemaId = normalizeId(schema.$id);\n  const baseIds = {\n    \"\": schemaId\n  };\n  const pathPrefix = getFullPath(schemaId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch.$id == \"string\") baseId = addRef.call(this, sch.$id);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n    function addRef(ref) {\n      ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n      return ref;\n    }\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"names":["util_1","require","equal","traverse","URI","SIMPLE_INLINED","Set","inlineRef","schema","limit","hasRef","countKeys","exports","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","eachItem","getFullPath","id","normalize","normalizeId","p","parse","_getFullPath","serialize","split","TRAILING_SLASH_HASH","replace","resolveUrl","baseId","resolve","ANCHOR","getSchemaRefs","schemaId","$id","baseIds","pathPrefix","localRefs","schemaRefs","allKeys","jsonPtr","_","parentJsonPtr","undefined","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\resolve.ts"],"sourcesContent":["import type {AnySchema, AnySchemaObject} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\nimport * as URI from \"uri-js\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = URI.parse(id)\n  return _getFullPath(p)\n}\n\nexport function _getFullPath(p: URI.URIComponents): string {\n  return URI.serialize(p).split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(baseId: string, id: string): string {\n  id = normalizeId(id)\n  return URI.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const schemaId = normalizeId(schema.$id)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schemaId}\n  const pathPrefix = getFullPath(schemaId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch.$id == \"string\") baseId = addRef.call(this, sch.$id)\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}