{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = void 0;\nconst dataType_1 = require(\"./validate/dataType\");\nconst util_1 = require(\"./util\");\nconst errors_1 = require(\"./errors\");\nconst codegen_1 = require(\"./codegen\");\nconst names_1 = require(\"./names\");\nconst subschema_1 = require(\"./subschema\");\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    validateKeywordUsage(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  result(condition, successAction, failAction) {\n    this.gen.if(codegen_1.not(condition));\n    if (failAction) failAction();else this.error();\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n  pass(condition, failAction) {\n    this.result(condition, undefined, failAction);\n  }\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n      return;\n    }\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail(codegen_1._`${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);\n  }\n  error(append) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error);\n  }\n  $dataError() {\n    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    errors_1.resetErrorsCount(this.gen, this.errsCount);\n  }\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n  block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n  check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if(codegen_1.or(codegen_1._`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n    gen.else();\n  }\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return codegen_1._`${dataType_1.checkDataTypes(st, schemaCode, it.opts.strict, dataType_1.DataType.Wrong)}`;\n      }\n      return codegen_1.nil;\n    }\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n        return codegen_1._`!${validateSchemaRef}(${schemaCode})`;\n      }\n      return codegen_1.nil;\n    }\n  }\n  subschema(appl, valid) {\n    return subschema_1.applySubschema(this.it, appl, valid);\n  }\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n}\nexports.default = KeywordCxt;\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nfunction validateKeywordUsage({\n  schema,\n  opts,\n  self\n}, def, keyword) {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  const deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      const msg = \"keyword value is invalid: \" + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, {\n  dataLevel,\n  dataNames,\n  dataPathArr\n}) {\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n  for (const segment of segments) {\n    if (segment) {\n      data = codegen_1._`${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;\n      expr = codegen_1._`${expr} && ${data}`;\n    }\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\nexports.getData = getData;","map":{"version":3,"names":["dataType_1","require","util_1","errors_1","codegen_1","names_1","subschema_1","KeywordCxt","constructor","it","def","keyword","validateKeywordUsage","gen","allErrors","data","schema","$data","opts","schemaValue","schemaRefOrVal","schemaType","parentSchema","params","schemaCode","const","getData","validSchemaType","allowUndefined","Error","JSON","stringify","trackErrors","errors","errsCount","default","result","condition","successAction","failAction","if","not","error","else","endIf","pass","undefined","fail","fail$data","_","or","invalid$data","append","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","setParams","obj","assign","Object","block$data","valid","codeBlock","$dataValid","nil","block","check$data","length","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","Name","st","Array","isArray","checkDataTypes","strict","DataType","Wrong","validateSchemaRef","scopeValue","ref","subschema","appl","applySubschema","mergeEvaluated","schemaCxt","toName","unevaluated","props","items","mergeValidEvaluated","exports","some","self","includes","deps","dependencies","kwd","prototype","hasOwnProperty","call","join","msg","errorsText","logger","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","rootData","test","matches","exec","up","errorMsg","expr","segments","split","segment","getProperty","unescapeJsonPointer","pointerType"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\context.ts"],"sourcesContent":["import type {\n  AddedKeywordDefinition,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n  AnySchemaObject,\n} from \"../types\"\nimport {SchemaCxt, SchemaObjCxt} from \"./index\"\nimport {JSONType} from \"./rules\"\nimport {checkDataTypes, DataType} from \"./validate/dataType\"\nimport {schemaRefOrVal, unescapeJsonPointer, mergeEvaluated} from \"./util\"\nimport {reportError, reportExtraError, resetErrorsCount, keyword$DataError} from \"./errors\"\nimport {CodeGen, _, nil, or, not, getProperty, Code, Name} from \"./codegen\"\nimport N from \"./names\"\nimport {applySubschema, SubschemaArgs} from \"./subschema\"\n\nexport default class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(not(condition))\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.result(condition, undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: true): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strict, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    return applySubschema(this.it, appl, valid)\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction validSchemaType(schema: unknown, schemaType: JSONType[], allowUndefined = false): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nfunction validateKeywordUsage(\n  {schema, opts, self}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg = \"keyword value is invalid: \" + self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}