{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applySubschema = exports.Type = void 0;\nconst validate_1 = require(\"./validate\");\nconst util_1 = require(\"./util\");\nconst codegen_1 = require(\"./codegen\");\nvar Type;\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction applySubschema(it, appl, valid) {\n  const subschema = getSubschema(it, appl);\n  extendSubschemaData(subschema, it, appl);\n  extendSubschemaMode(subschema, appl);\n  const nextContext = {\n    ...it,\n    ...subschema,\n    items: undefined,\n    props: undefined\n  };\n  validate_1.subschemaCode(nextContext, valid);\n  return nextContext;\n}\nexports.applySubschema = applySubschema;\nfunction getSubschema(it, {\n  keyword,\n  schemaProp,\n  schema,\n  schemaPath,\n  errSchemaPath,\n  topSchemaRef\n}) {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: codegen_1._`${it.schemaPath}${codegen_1.getProperty(keyword)}${codegen_1.getProperty(schemaProp)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}/${util_1.escapeFragment(schemaProp)}`\n    };\n  }\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nfunction extendSubschemaData(subschema, it, {\n  dataProp,\n  dataPropType: dpType,\n  data,\n  dataTypes,\n  propertyName\n}) {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n  const {\n    gen\n  } = it;\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", codegen_1._`${it.data}${codegen_1.getProperty(dataProp)}`, true);\n    dataContextProps(nextData);\n    subschema.errorPath = codegen_1.str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;\n    subschema.parentDataProperty = codegen_1._`${dataProp}`;\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName;\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n  if (dataTypes) subschema.dataTypes = dataTypes;\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\nfunction extendSubschemaMode(subschema, {\n  jtdDiscriminator,\n  jtdMetadata,\n  compositeRule,\n  createErrors,\n  allErrors\n}) {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? codegen_1._`\"[\" + ${dataProp} + \"]\"` : codegen_1._`\"['\" + ${dataProp} + \"']\"` : isNumber ? codegen_1._`\"/\" + ${dataProp}` : codegen_1._`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : \"/\" + util_1.escapeJsonPointer(dataProp);\n}","map":{"version":3,"names":["validate_1","require","util_1","codegen_1","Type","exports","applySubschema","it","appl","valid","subschema","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","items","undefined","props","subschemaCode","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","Error","sch","_","getProperty","escapeFragment","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","dataContextProps","str","getErrorPath","jsPropertySyntax","parentDataProperty","Name","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors","isNumber","Num","toString","escapeJsonPointer"],"sources":["C:\\Users\\obaid\\Work Projects\\BID\\node_modules\\ajv\\lib\\compile\\subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../types\"\nimport type {SchemaObjCxt, SchemaCxt} from \"./index\"\nimport {subschemaCode} from \"./validate\"\nimport {escapeFragment, escapeJsonPointer} from \"./util\"\nimport {_, str, Code, Name, getProperty} from \"./codegen\"\nimport {JSONType} from \"./rules\"\n\ninterface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function applySubschema(it: SchemaObjCxt, appl: SubschemaArgs, valid: Name): SchemaCxt {\n  const subschema = getSubschema(it, appl)\n  extendSubschemaData(subschema, it, appl)\n  extendSubschemaMode(subschema, appl)\n  const nextContext = {...it, ...subschema, items: undefined, props: undefined}\n  subschemaCode(nextContext, valid)\n  return nextContext\n}\n\nfunction getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nfunction extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nfunction extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n\nfunction getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n"],"mappings":";;;;;;AAEA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,SAAA,GAAAF,OAAA;AAyBA,IAAYG,IAGX;AAHD,WAAYA,IAAI;EACdA,IAAA,CAAAA,IAAA,oBAAG;EACHA,IAAA,CAAAA,IAAA,oBAAG;AACL,CAAC,EAHWA,IAAI,GAAJC,OAAA,CAAAD,IAAI,KAAJC,OAAA,CAAAD,IAAI;AAyBhB,SAAgBE,cAAcA,CAACC,EAAgB,EAAEC,IAAmB,EAAEC,KAAW;EAC/E,MAAMC,SAAS,GAAGC,YAAY,CAACJ,EAAE,EAAEC,IAAI,CAAC;EACxCI,mBAAmB,CAACF,SAAS,EAAEH,EAAE,EAAEC,IAAI,CAAC;EACxCK,mBAAmB,CAACH,SAAS,EAAEF,IAAI,CAAC;EACpC,MAAMM,WAAW,GAAG;IAAC,GAAGP,EAAE;IAAE,GAAGG,SAAS;IAAEK,KAAK,EAAEC,SAAS;IAAEC,KAAK,EAAED;EAAS,CAAC;EAC7EhB,UAAA,CAAAkB,aAAa,CAACJ,WAAW,EAAEL,KAAK,CAAC;EACjC,OAAOK,WAAW;AACpB;AAPAT,OAAA,CAAAC,cAAA,GAAAA,cAAA;AASA,SAASK,YAAYA,CACnBJ,EAAgB,EAChB;EAACY,OAAO;EAAEC,UAAU;EAAEC,MAAM;EAAEC,UAAU;EAAEC,aAAa;EAAEC;AAAY,CAAgB;EAErF,IAAIL,OAAO,KAAKH,SAAS,IAAIK,MAAM,KAAKL,SAAS,EAAE;IACjD,MAAM,IAAIS,KAAK,CAAC,sDAAsD,CAAC;;EAGzE,IAAIN,OAAO,KAAKH,SAAS,EAAE;IACzB,MAAMU,GAAG,GAAGnB,EAAE,CAACc,MAAM,CAACF,OAAO,CAAC;IAC9B,OAAOC,UAAU,KAAKJ,SAAS,GAC3B;MACEK,MAAM,EAAEK,GAAG;MACXJ,UAAU,EAAEnB,SAAA,CAAAwB,CAAC,GAAGpB,EAAE,CAACe,UAAU,GAAGnB,SAAA,CAAAyB,WAAW,CAACT,OAAO,CAAC,EAAE;MACtDI,aAAa,EAAE,GAAGhB,EAAE,CAACgB,aAAa,IAAIJ,OAAO;KAC9C,GACD;MACEE,MAAM,EAAEK,GAAG,CAACN,UAAU,CAAC;MACvBE,UAAU,EAAEnB,SAAA,CAAAwB,CAAC,GAAGpB,EAAE,CAACe,UAAU,GAAGnB,SAAA,CAAAyB,WAAW,CAACT,OAAO,CAAC,GAAGhB,SAAA,CAAAyB,WAAW,CAACR,UAAU,CAAC,EAAE;MAChFG,aAAa,EAAE,GAAGhB,EAAE,CAACgB,aAAa,IAAIJ,OAAO,IAAIjB,MAAA,CAAA2B,cAAc,CAACT,UAAU,CAAC;KAC5E;;EAGP,IAAIC,MAAM,KAAKL,SAAS,EAAE;IACxB,IAAIM,UAAU,KAAKN,SAAS,IAAIO,aAAa,KAAKP,SAAS,IAAIQ,YAAY,KAAKR,SAAS,EAAE;MACzF,MAAM,IAAIS,KAAK,CAAC,6EAA6E,CAAC;;IAEhG,OAAO;MACLJ,MAAM;MACNC,UAAU;MACVE,YAAY;MACZD;KACD;;EAGH,MAAM,IAAIE,KAAK,CAAC,6CAA6C,CAAC;AAChE;AAEA,SAASb,mBAAmBA,CAC1BF,SAA2B,EAC3BH,EAAgB,EAChB;EAACuB,QAAQ;EAAEC,YAAY,EAAEC,MAAM;EAAEC,IAAI;EAAEC,SAAS;EAAEC;AAAY,CAAgB;EAE9E,IAAIF,IAAI,KAAKjB,SAAS,IAAIc,QAAQ,KAAKd,SAAS,EAAE;IAChD,MAAM,IAAIS,KAAK,CAAC,qDAAqD,CAAC;;EAGxE,MAAM;IAACW;EAAG,CAAC,GAAG7B,EAAE;EAEhB,IAAIuB,QAAQ,KAAKd,SAAS,EAAE;IAC1B,MAAM;MAACqB,SAAS;MAAEC,WAAW;MAAEC;IAAI,CAAC,GAAGhC,EAAE;IACzC,MAAMiC,QAAQ,GAAGJ,GAAG,CAACK,GAAG,CAAC,MAAM,EAAEtC,SAAA,CAAAwB,CAAC,GAAGpB,EAAE,CAAC0B,IAAI,GAAG9B,SAAA,CAAAyB,WAAW,CAACE,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC;IAC7EY,gBAAgB,CAACF,QAAQ,CAAC;IAC1B9B,SAAS,CAAC2B,SAAS,GAAGlC,SAAA,CAAAwC,GAAG,GAAGN,SAAS,GAAGO,YAAY,CAACd,QAAQ,EAAEE,MAAM,EAAEO,IAAI,CAACM,gBAAgB,CAAC,EAAE;IAC/FnC,SAAS,CAACoC,kBAAkB,GAAG3C,SAAA,CAAAwB,CAAC,GAAGG,QAAQ,EAAE;IAC7CpB,SAAS,CAAC4B,WAAW,GAAG,CAAC,GAAGA,WAAW,EAAE5B,SAAS,CAACoC,kBAAkB,CAAC;;EAGxE,IAAIb,IAAI,KAAKjB,SAAS,EAAE;IACtB,MAAMwB,QAAQ,GAAGP,IAAI,YAAY9B,SAAA,CAAA4C,IAAI,GAAGd,IAAI,GAAGG,GAAG,CAACK,GAAG,CAAC,MAAM,EAAER,IAAI,EAAE,IAAI,CAAC,EAAC;IAC3ES,gBAAgB,CAACF,QAAQ,CAAC;IAC1B,IAAIL,YAAY,KAAKnB,SAAS,EAAEN,SAAS,CAACyB,YAAY,GAAGA,YAAY;IACrE;;EAGF,IAAID,SAAS,EAAExB,SAAS,CAACwB,SAAS,GAAGA,SAAS;EAE9C,SAASQ,gBAAgBA,CAACM,SAAe;IACvCtC,SAAS,CAACuB,IAAI,GAAGe,SAAS;IAC1BtC,SAAS,CAACuC,SAAS,GAAG1C,EAAE,CAAC0C,SAAS,GAAG,CAAC;IACtCvC,SAAS,CAACwB,SAAS,GAAG,EAAE;IACxB3B,EAAE,CAAC2C,iBAAiB,GAAG,IAAIC,GAAG,EAAU;IACxCzC,SAAS,CAAC0C,UAAU,GAAG7C,EAAE,CAAC0B,IAAI;IAC9BvB,SAAS,CAAC2C,SAAS,GAAG,CAAC,GAAG9C,EAAE,CAAC8C,SAAS,EAAEL,SAAS,CAAC;EACpD;AACF;AAEA,SAASnC,mBAAmBA,CAC1BH,SAA2B,EAC3B;EAAC4C,gBAAgB;EAAEC,WAAW;EAAEC,aAAa;EAAEC,YAAY;EAAEC;AAAS,CAAgB;EAEtF,IAAIF,aAAa,KAAKxC,SAAS,EAAEN,SAAS,CAAC8C,aAAa,GAAGA,aAAa;EACxE,IAAIC,YAAY,KAAKzC,SAAS,EAAEN,SAAS,CAAC+C,YAAY,GAAGA,YAAY;EACrE,IAAIC,SAAS,KAAK1C,SAAS,EAAEN,SAAS,CAACgD,SAAS,GAAGA,SAAS;EAC5DhD,SAAS,CAAC4C,gBAAgB,GAAGA,gBAAgB,EAAC;EAC9C5C,SAAS,CAAC6C,WAAW,GAAGA,WAAW,EAAC;AACtC;AAEA,SAASX,YAAYA,CACnBd,QAAgC,EAChCC,YAAmB,EACnBc,gBAA0B;EAE1B;EACA,IAAIf,QAAQ,YAAY3B,SAAA,CAAA4C,IAAI,EAAE;IAC5B,MAAMY,QAAQ,GAAG5B,YAAY,KAAK3B,IAAI,CAACwD,GAAG;IAC1C,OAAOf,gBAAgB,GACnBc,QAAQ,GACNxD,SAAA,CAAAwB,CAAC,SAASG,QAAQ,QAAQ,GAC1B3B,SAAA,CAAAwB,CAAC,UAAUG,QAAQ,SAAS,GAC9B6B,QAAQ,GACRxD,SAAA,CAAAwB,CAAC,SAASG,QAAQ,EAAE,GACpB3B,SAAA,CAAAwB,CAAC,SAASG,QAAQ,4CAA4C,EAAC;;EAErE,OAAOe,gBAAgB,GAAG1C,SAAA,CAAAyB,WAAW,CAACE,QAAQ,CAAC,CAAC+B,QAAQ,EAAE,GAAG,GAAG,GAAG3D,MAAA,CAAA4D,iBAAiB,CAAChC,QAAQ,CAAC;AAChG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}